# webserver.cpp整体逻辑
- 实现了一个 HTTP 连接类 HttpConn，封装了 HTTP 连接的一些操作，比如读写数据、处理请求等。

- 实现了一个线程池 ThreadPool，用来管理多个线程，同时也提供了添加任务的接口。

- 实现了一个定时器 HeapTimer，用来管理超时连接，以及提供添加定时任务的接口。

- 实现了一个 epoll 封装类 Epoller，用来管理事件，同时提供了添加、删除和修改事件的接口。

- 实现了一个 Web 服务器类 WebServer，封装了 HTTP 服务器的启动、停止、监听等操作，同时也实现了一个简单的事件循环，处理事件和请求。

- 使用了单例模式实现了一个数据库连接池 SqlConnPool，用来管理数据库连接，以及提供获取和释放连接的接口。

在这段代码中，主要实现了 Web 服务器的启动、事件循环、事件处理等功能。其中，事件循环部分使用了 epoll_wait() 函数来监听事件，并通过事件处理函数来处理不同类型的事件，比如接收连接请求、读取数据、写入数据等。同时，还使用了线程池来处理数据读写、请求处理等任务，提高了服务器的并发处理能力。


## 端口复用
在服务器启动时，服务器程序会创建一个监听套接字（listening socket），并绑定到服务器端的某个 IP 地址和端口上。然后，服务器程序会使用监听套接字来接受来自客户端的连接请求，每当有一个新的连接请求到达时，服务器程序会使用 accept() 函数创建一个新的套接字，然后使用这个新的套接字来与客户端进行通信。由于多个客户端可能同时向服务器发送连接请求，因此服务器需要支持同时监听多个连接请求，这就需要在同一个 IP 地址和端口上创建多个套接字。为了支持这种功能，可以使用 SO_REUSEADDR 选项来允许多个套接字同时绑定到同一端口上。

使用端口复用允许多个套接字同时绑定到同一端口上，这样只需要一个服务器套接字就可以同时处理多个客户端套接字的连接请求。这种方式可以提高服务器的并发性能，避免资源浪费。

### std::bind()
在C++中，bind函数的作用是创建一个新的可调用对象（函数、函数对象或者成员函数指针），该可调用对象与原始函数或者函数对象有相同的行为，但是其参数绑定了一些值或者对象。这些绑定的参数或对象可以是占位符（_1、_2、_3等）、具体的值、或者是引用或指针。

bind函数通常用于将一个有多个参数的函数转换为一个只接受部分参数的函数或者函数对象，或者用于将成员函数转换为普通函数或者函数对象。

bind函数的基本语法如下：
```c++
#include <functional>

std::function<返回值类型(参数类型)> bind(std::function<返回值类型(参数类型)> f, 绑定的参数);

```

其中，f是待绑定的函数对象，可以是普通函数、函数指针、成员函数指针等；绑定的参数是需要绑定到函数对象上的参数，可以是占位符、具体的值、引用或指针。

例如，假设有一个函数void foo(int a, int b, int c)，我们可以使用bind函数创建一个新的函数对象，该函数对象只接受两个参数，第三个参数c被绑定为42，代码如下：
```c++
#include <functional>
#include <iostream>

void foo(int a, int b, int c) {
    std::cout << "a = " << a << ", b = " << b << ", c = " << c << std::endl;
}

int main() {
    auto bar = std::bind(foo, std::placeholders::_1, std::placeholders::_2, 42);
    bar(1, 2);  //输出：a = 1, b = 2, c = 42
    return 0;
}

```

在这个例子中，bind(foo, std::placeholders::_1, std::placeholders::_2, 42)创建了一个新的函数对象bar，它接受两个参数，其中第一个参数绑定到foo函数的第一个参数上，第二个参数绑定到foo函数的第二个参数上，而第三个参数42则被绑定到foo函数的第三个参数上。调用bar(1, 2)相当于调用了foo(1, 2, 42)。

**std::bind(&WebServer::OnRead_, this, client) 根据这个函数来解释bind**
std::bind 是 C++11 中引入的一个函数对象适配器，它可以将一个成员函数指针和其所属的对象一起绑定，生成一个新的可调用对象，这个对象可以在后续调用时，不需要再指定对象，只需要传入函数的其他参数即可。

具体来说，std::bind 函数接受若干个参数，第一个参数是要绑定的成员函数指针，第二个参数是绑定的对象指针（或引用），后续的参数是该函数的实参。最终生成一个新的函数对象，可以调用该函数。

例如，在上述代码中，std::bind(&WebServer::OnRead_, this, client) 绑定了 WebServer 类中的成员函数 OnRead_，并将当前对象指针 this 和一个指向 HttpConn 对象的指针 client 绑定为其参数，最终生成一个新的可调用对象，可以在后续线程池任务中调用该函数，并传入其他的实参。

使用std::bind可以将一个成员函数绑定到一个对象上，得到一个可调用对象，**这个对象可以在不需要对象实例的情况下被调用**。这个特性在多线程编程中很有用，比如上面的代码使用线程池来处理HTTP连接的读操作，可以将WebServer的成员函数OnRead_绑定到client上，然后将这个可调用对象作为任务添加到线程池中，等待线程池的一个线程来执行。

使用std::bind的好处是，将成员函数和对象进行绑定后，可以将这个可调用对象作为参数传递给其他函数或线程，并在需要的时候进行调用，这样可以方便地将任务分配到多个线程中执行，提高程序的并发性能。同时，std::bind还可以绑定一些参数，使得在调用时可以传递更多的参数给函数，增强了函数的灵活性。

### 端口复用
端口复用是指在一个网络接口上开启多个应用程序或者进程使用同一个端口的方式。通过端口复用，可以实现多个应用程序或者进程同时监听同一个端口，从而提高网络资源的利用率。在 Linux 中，可以使用 setsockopt 函数设置 SO_REUSEADDR 选项来开启端口复用功能。

如果不使用端口复用，当一个TCP连接断开时，操作系统会将该端口号绑定的socket占用一段时间（通常为几分钟），在此期间，其他程序无法使用该端口号。这可能导致端口资源的浪费和服务器性能的降低。使用端口复用可以避免这种情况，允许多个socket共享同一个端口，从而提高端口资源的利用率和服务器性能。


### epoll_ctl
在 Linux 系统中，epoll 是一种高效的 I/O 多路复用机制。而 epoll_ctl() 函数是用来向 epoll 实例中添加、修改或删除文件描述符的函数。其中，ctl 是 control 的缩写，表示该函数是用来控制 epoll 实例的。该函数的具体作用如下：

- 添加文件描述符：通过将新的文件描述符添加到 epoll 实例中来监控该文件描述符上的 I/O 事件。
- 修改文件描述符：修改 epoll 实例中已有的文件描述符的属性，例如添加、删除或修改事件类型。
- 删除文件描述符：从 epoll 实例中删除一个文件描述符，停止监控该文件描述符上的 I/O 事件。
因此，epoll_ctl() 函数的作用是控制 epoll 实例中文件描述符的状态，使得程序能够高效地进行 I/O 多路复用。

epoll_ctl() 函数的返回值是一个整数类型的值，它表示函数执行的成功或失败状态。其返回值的含义如下：

- 如果函数执行成功，则返回 0。
- 如果函数执行失败，则返回 -1，并且设置 errno 变量来表示错误类型。errno 变量是一个整型变量，它保存了上一个系统调用执行失败的错误码。可以通过 strerror() 函数来将错误码转换成可读的字符串信息，以便于程序员进行错误处理。

在使用 epoll_ctl() 函数时，应该始终检查其返回值，以确保函数执行成功。如果函数执行失败，则应该根据错误码来判断错误类型，并采取相应的错误处理措施。

### 文件描述符的时间类型
Linux 系统中 epoll 实例中文件描述符的事件类型，它们表示不同类型的 I/O 事件。下面是对这些参数的详细解释：

- EPOLLOUT：表示可写事件。当一个连接的发送缓冲区变为可写时，就会触发该事件。可以通过调用 write() 函数向连接的发送缓冲区中写入数据。

- EPOLLIN：表示可读事件。当一个连接的接收缓冲区中有数据可读时，就会触发该事件。可以通过调用 read() 函数从连接的接收缓冲区中读取数据。

- EPOLLRDHUP：表示连接被对端关闭。当一个连接的对端关闭时，就会触发该事件。可以通过调用 close() 函数关闭连接。

- EPOLLHUP：表示连接发生异常。当一个连接发生异常时，就会触发该事件。例如，连接被重置或者对端崩溃等情况。

- EPOLLERR：表示连接发生错误。当一个连接发生错误时，就会触发该事件。例如，连接超时、连接被拒绝或者连接不存在等情况。

这些事件类型是通过调用 epoll_ctl() 函数来向 epoll 实例中添加、修改或删除文件描述符时设置的。在实际的程序开发中，我们可以根据需要添加相应的事件类型，以便于程序能够正确地处理不同类型的 I/O 事件。

