# 日志系统运行机制
这三段代码实现了一个简单的异步日志系统，它的运行机制如下：

- 在main函数中初始化日志系统，可以指定日志级别、日志存储路径、日志文件后缀以及日志缓冲区最大容量等参数。

- 在需要记录日志的地方，可以通过宏定义（如LOG_DEBUG、LOG_INFO等）来记录不同级别的日志，具体的日志内容可以采用printf函数的格式化字符串实现。

- 在记录日志时，日志系统首先判断当前的日志级别是否满足要求，如果不满足，则直接返回。如果满足，则将日志内容写入缓冲区。

- 当缓冲区满了或者达到一定条件时（比如一天的时间已经过去了），将缓冲区的内容写入日志文件中。写入日志文件的过程是异步进行的，即通过一个线程来处理。

- 日志系统支持异步模式和同步模式，可以通过初始化时的参数来选择。异步模式下，日志内容会先被放入一个阻塞队列中，然后由专门的线程来处理。同步模式下，日志内容会直接写入日志文件中。

- 当程序退出时，需要手动调用日志系统的关闭函数，以确保所有的日志内容都被写入到日志文件中。

总体来说，这个日志系统实现比较简单，但是已经具备了基本的功能，可以满足一般的日志记录需求。




# std::unique_lock和std::lock_guard的区别

在代码中，std::unique_lock被用于pop()函数(不仅是pop，添加和删除元素都是)中，因为在等待共享资源时需要使用wait_for()来等待一段时间，而std::unique_lock提供了更好的支持。
而std::lock_guard则被用于其他函数中，因为这些函数中只需要简单的锁定和解锁互斥量即可。

用pop函数举个例子说明为什么要用std::unique_lock:
在pop()函数中，线程需要等待队列中有数据才能进行取出操作。如果队列为空，线程需要等待其他线程将数据放入队列。为了实现等待，需要使用条件变量和锁。在等待期间，需要将锁释放以允许其他线程访问共享资源，这是为了防止其他线程被阻塞。如果使用std::lock_guard来锁定锁，锁将在该对象的生命周期结束时自动解锁。这意味着在等待期间，锁会被锁定，其他线程无法访问共享资源。因此，需要使用std::unique_lock，它允许在等待期间手动释放锁，并在需要时重新获取锁。在pop()函数中，需要等待一段时间以避免永久阻塞，所以使用std::unique_lock提供的wait_for()函数来等待一段时间。





std::unique_lock 和 std::lock_guard 都是 C++ 标准库中用来保护共享资源的锁的封装类。它们的区别在于：
1. 拥有资源：std::lock_guard 对象在构造时锁住 mutex，在析构时解锁；而 std::unique_lock 对象可以控制锁的获取和释放的时机，它可以在任意时间点上锁和解锁 mutex。

2. 转移所有权：std::unique_lock 对象可以转移 mutex 所有权，也就是可以将一个 unique_lock 对象从一个线程传递给另一个线程，而 std::lock_guard 对象不能转移所有权。

3. 可以解锁：std::unique_lock 对象可以手动解锁 mutex，并在需要时重新锁定，而 std::lock_guard 对象不能手动解锁。

什么时候使用std::unique_lock, 什么时候使用std::lock_guard?
- std::unique_lock 和 std::lock_guard 都可以用来保护共享资源，确保在临界区内代码执行期间其他线程不会访问共享资源。

- std::lock_guard 是一个轻量级的互斥量封装，适用于对共享资源短时间的独占式访问，不支持手动释放锁。当 std::lock_guard 对象被析构时，会自动释放锁。

- std::unique_lock 是一个更加灵活的互斥量封装，支持手动释放锁，适用于需要中途退出临界区的场景。std::unique_lock 还提供了与条件变量配合使用的功能，可以在等待条件变量时释放锁，等到条件满足时再重新获得锁。

- 因此，当需要手动释放锁或等待条件变量时，应使用 std::unique_lock；当只需要短时间的独占式访问共享资源时，应使用 std::lock_guard。

## blockqueue.h
这是一个使用 C++ 标准库的多线程安全的阻塞队列实现，支持 push 和 pop 操作，并可以指定超时时间。队列实现采用双端队列（deque），底层使用互斥量（mutex）和条件变量（condition_variable）来保证线程安全。队列满时 push 操作会阻塞，直到队列中有空闲位置；队列空时 pop 操作会阻塞，直到队列中有数据。同时，该队列还可以支持清空（clear）和批量推送（flush）等操作。 该队列实现可以被用于生产者-消费者模式中，生产者可以向队列中推入数据，消费者可以从队列中获取数据。当队列满时，生产者会阻塞等待，直到队列中有空闲位置；当队列空时，消费者会阻塞等待，直到队列中有数据。


## log.h
log.h 中定义了一个名为 Log 的日志类，支持初始化、写日志、刷日志等操作，同时还支持异步写日志和同步写日志。该类支持四个日志等级：DEBUG、INFO、WARN、ERROR。可以通过 setLevel() 方法设置日志等级，低于该等级的日志将被过滤掉。还可以通过设置异步写日志标志来选择是否启用异步写日志。该类还使用了 blockqueue.h 中的 BlockQueue 类来实现异步写日志的功能。


## tm 结构体
```c++
struct tm {
  int tm_sec;   // 秒，取值范围为[0, 60]，但是通常只有[0, 59]是合法的
  int tm_min;   // 分钟，取值范围为[0, 59]
  int tm_hour;  // 小时，取值范围为[0, 23]
  int tm_mday;  // 一个月中的第几天，取值范围为[1, 31]
  int tm_mon;   // 月份，取值范围为[0, 11]，0 表示一月，11 表示十二月
  int tm_year;  // 年份，以公元 1900 年为起点，例如 121 表示 2021 年
  int tm_wday;  // 一周中的第几天，取值范围为[0, 6]，0 表示周日，1 表示周一，以此类推
  int tm_yday;  // 一年中的第几天，取值范围为[0, 365]，0 表示一月一日
  int tm_isdst; // 夏令时标识，通常为正数表示启用夏令时，0 表示未启用夏令时，负数表示无法确定是否启用夏令时
};


```